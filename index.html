<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Battleship ML (WASM)</title>
    <style>
      body { font-family: monospace; background:#0b0e12; color:#e6e6e6; margin:0; padding:20px; }
      #ui { display: flex; flex-direction: column; gap: 20px; }
      .boards-row { display: flex; flex-direction: row; gap: 40px; justify-content: center; }
      .board-container { display: flex; flex-direction: column; align-items: center; }
      .board-container h3 { margin: 0 0 10px 0; font-size: 16px; text-align: center; }
      canvas { border:1.5px solid #333; background:#0b0e12; max-width: 100%; height: auto; width: 100%; }
      .stats { background:#0a0d11; padding:10px 18px; border:1px solid #333; margin-top: 10px; font-size: 13px; border-radius: 6px; }
      .stats div { margin: 4px 0; }
      .controls-row { display: flex; flex-direction: row; gap: 18px; align-items: flex-end; flex-wrap: wrap; margin-bottom: 8px; }
      .controls-group { background:#0a0d11; padding:10px 16px; border:1px solid #333; border-radius: 6px; display: flex; flex-direction: column; gap: 6px; min-width: 180px; }
      .controls-group label, .controls-group select, .controls-group input, .controls-group button { font-size: 13px; margin: 0; }
      .controls-group button { margin-top: 6px; }
      .legend { font-size: 11px; margin-top: 10px; }
      .legend div { display: flex; align-items: center; gap: 8px; margin: 4px 0; }
      .legend .box { width: 20px; height: 20px; border: 1px solid #333; }
      #log-container { background:#0a0d11; border:1px solid #333; border-radius: 6px; margin-top: 0; min-width: 220px; max-width: 100vw; }
      #log-label { font-size: 13px; font-weight: bold; margin: 0 0 4px 0; padding: 8px 12px 0 12px; }
      #log { height: 160px; max-height: 160px; min-height: 160px; overflow-y: auto; background: none; border: none; padding: 0 12px 12px 12px; font-size: 13px; min-width: 0; word-break: break-word; }

      @media (max-width: 900px) {
        .boards-row { flex-direction: column; gap: 20px; align-items: center; }
        .controls-row { flex-direction: column; gap: 12px; align-items: stretch; }
        #log-container { min-width: 0; max-width: 100vw; }
      }
      @media (max-width: 600px) {
        body { padding: 6px; }
        .board-container h3 { font-size: 13px; }
        canvas { width: 98vw; height: auto; min-width: 0; }
        .controls-group { padding: 7px 4px; min-width: 0; font-size: 12px; }
        .controls-group label, .controls-group select, .controls-group input, .controls-group button { font-size: 12px; }
        .stats { font-size: 11px; padding: 7px 6px; }
        #log-label { font-size: 12px; padding: 6px 8px 0 8px; }
        #log { font-size: 12px; padding: 0 8px 8px 8px; }
      }
    </style>
    </style>
  </head>
  <body>
    <h1 style="margin-bottom: 4px;">Battleship ML (C++ → WebAssembly)</h1>
    <div style="margin-bottom: 18px; font-size: 15px;">
      by <a href="https://github.com/JohnScarrow" target="_blank" rel="noopener" style="color:#4cafef;text-decoration:underline;">John Scarrow</a>
    </div>
    <div id="ui">
      <div class="boards-row">
        <div class="board-container">
          <h3>Player 1 Board (AI Targeting)</h3>
          <canvas id="board1" width="400" height="400"></canvas>
          <div class="stats" id="stats1">
            <div>Hits: <span id="p1-hits">0</span></div>
            <div>Misses: <span id="p1-misses">0</span></div>
            <div>Total Shots: <span id="p1-total">0</span></div>
            <div>Accuracy: <span id="p1-acc">0%</span></div>
          </div>
        </div>
        <div class="board-container">
          <h3>Player 2 Board (AI Targeting)</h3>
          <canvas id="board2" width="400" height="400"></canvas>
          <div class="stats" id="stats2">
            <div>Hits: <span id="p2-hits">0</span></div>
            <div>Misses: <span id="p2-misses">0</span></div>
            <div>Total Shots: <span id="p2-total">0</span></div>
            <div>Accuracy: <span id="p2-acc">0%</span></div>
          </div>
        </div>
      </div>
      <div class="controls-row">
        <div class="controls-group">
          <label for="mode">Game Mode</label>
          <select id="mode">
            <option value="3">AI vs AI (autoplay)</option>
            <option value="2">You vs AI (auto)</option>
            <option value="1">2 Player (auto)</option>
          </select>
          <label for="games">Number of Games</label>
          <input id="games" type="number" min="1" value="50"/>
          <label><input type="checkbox" id="stepMode"/> Step Mode</label>
          <div style="display:flex; gap:6px;">
            <button id="start">Start</button>
            <button id="step" disabled>Step</button>
            <button id="resume" disabled>Resume</button>
          </div>
          <label>Speed: <span id="speedVal">60</span> ticks/sec</label>
          <input id="speedSlider" type="range" min="1" max="200" value="60" />
        </div>
        <div class="controls-group">
          <strong>AI Quick Tuning</strong>
          <label>Alpha (early): <span id="alphaVal">0.75</span></label>
          <input id="alphaSlider" type="range" min="0.40" max="0.95" step="0.01" value="0.75" />
          <label>Placement Multiplier: <span id="placeVal">2.00</span></label>
          <input id="placeSlider" type="range" min="0.50" max="3.00" step="0.05" value="2.00" />
          <label>Adjacency Bonus: <span id="adjVal">0.40</span></label>
          <input id="adjSlider" type="range" min="0.00" max="1.00" step="0.01" value="0.40" />
          <label>MC Blend Ratio: <span id="mcVal">0.50</span></label>
          <input id="mcSlider" type="range" min="0.00" max="1.00" step="0.01" value="0.50" />
          <button id="applyAI">Apply AI Weights</button>
          <button id="quickTrial">Quick 20-game Trial</button>
          <button id="applyBest">Use Best from tuner_output.csv</button>
        </div>
        <div class="controls-group">
          <label>Presets</label>
          <select id="presetSel">
            <option value="default">Default</option>
            <option value="fast-center">Fast-Center</option>
            <option value="tuned-best">Tuned-Best</option>
          </select>
          <button id="savePreset">Save Preset</button>
          <div id="tunerSummary" style="margin-top:8px; font-size:12px"></div>
        </div>
        <div class="controls-group legend">
          <div><div class="box" style="background:#4caf50"></div> Hit</div>
          <div><div class="box" style="background:#e53935"></div> Miss</div>
          <div><div class="box" style="background:rgba(0,140,255,0.5)"></div> AI Heatmap</div>
        </div>
      </div>
      <div id="log-container">
        <div id="log-label">Game Log</div>
        <pre id="log"></pre>
      </div>
    </div>

    <script type="module">
      import createModule from "./dist/battleship.js";

      let mod;
      try {
        mod = await createModule({
          print: t => console.log(t),
          printErr: t => console.error(t),
        });
        console.log("WASM module loaded successfully");
      } catch (err) {
        console.error("Failed to load WASM module:", err);
        document.getElementById('log').textContent = `Error loading WASM: ${err.message}`;
        throw err;
      }

      const start = mod.cwrap('startTournament', null, ['number','number']);
      const tick  = mod.cwrap('tickTournament', 'string', []);
      const done  = mod.cwrap('isTournamentDone', 'number', []);
      const snap  = mod.cwrap('getBoardSnapshot', 'number', []);
      const heat  = mod.cwrap('getHeatmapSnapshot', 'number', []);
      const snap1 = mod.cwrap('getPlayer1BoardSnapshot', 'number', []);
      const snap2 = mod.cwrap('getPlayer2BoardSnapshot', 'number', []);
      const heat1 = mod.cwrap('getPlayer1HeatmapSnapshot', 'number', []);
      const heat2 = mod.cwrap('getPlayer2HeatmapSnapshot', 'number', []);
      const setAIWeights = mod.cwrap('setAIWeightsFromArray', null, ['number']);
      const getAIWeights = mod.cwrap('getAIWeightsToArray', null, ['number']);

      const canvas1 = document.getElementById('board1');
      const canvas2 = document.getElementById('board2');
      const ctx1 = canvas1.getContext('2d');
      const ctx2 = canvas2.getContext('2d');
      const logEl = document.getElementById('log');
      const startBtn = document.getElementById('start');
      const modeSel = document.getElementById('mode');
      const gamesInput = document.getElementById('games');
      const speedSlider = document.getElementById('speedSlider');
      const speedVal = document.getElementById('speedVal');

      const alphaSlider = document.getElementById('alphaSlider');
      const alphaVal = document.getElementById('alphaVal');
      const placeSlider = document.getElementById('placeSlider');
      const placeVal = document.getElementById('placeVal');
      const adjSlider = document.getElementById('adjSlider');
      const adjVal = document.getElementById('adjVal');
      const mcSlider = document.getElementById('mcSlider');
      const mcVal = document.getElementById('mcVal');
      const applyAIBtn = document.getElementById('applyAI');
      const quickTrialBtn = document.getElementById('quickTrial');
      const applyBestBtn = document.getElementById('applyBest');
      const presetSel = document.getElementById('presetSel');
      const savePresetBtn = document.getElementById('savePreset');
      const tunerSummary = document.getElementById('tunerSummary');

      let p1Stats = { hits: 0, misses: 0, total: 0 };
      let p2Stats = { hits: 0, misses: 0, total: 0 };

      function updateStats(player, hits, misses, total) {
        const acc = total > 0 ? ((hits / total) * 100).toFixed(1) : 0;
        document.getElementById(`p${player}-hits`).textContent = hits;
        document.getElementById(`p${player}-misses`).textContent = misses;
        document.getElementById(`p${player}-total`).textContent = total;
        document.getElementById(`p${player}-acc`).textContent = acc + '%';
      }

      function renderBoardToCanvas(ctx, data, hdata, width, height) {
        const size = 10, cell = width / size;
        
        // Clear with dark background
        ctx.fillStyle = '#0b0e12'; 
        ctx.fillRect(0, 0, width, height);
        
        for (let r = 0; r < size; r++) {
          for (let c = 0; c < size; c++) {
            const idx = r * size + c;
            const v = data[idx];
            const hv = hdata[idx];
            
            // Draw cell background (empty cells get a slight gray to show grid)
            ctx.fillStyle = '#1a1d24';
            ctx.fillRect(c * cell + 1, r * cell + 1, cell - 2, cell - 2);
            
            // Heatmap overlay for untouched cells
            if (v === 0 && hv > 0) {
              const alpha = 0.15 + 0.65 * hv;
              ctx.fillStyle = `rgba(0,140,255,${alpha.toFixed(3)})`;
              ctx.fillRect(c * cell + 1, r * cell + 1, cell - 2, cell - 2);
            }
            
            // Hits - bright green
            if (v === 1) { 
              ctx.fillStyle = '#4caf50'; 
              ctx.fillRect(c * cell + 1, r * cell + 1, cell - 2, cell - 2);
            } 
            // Misses - red
            else if (v === -1) { 
              ctx.fillStyle = '#e53935'; 
              ctx.fillRect(c * cell + 1, r * cell + 1, cell - 2, cell - 2);
            }
            
            // Visible grid lines
            ctx.strokeStyle = '#4a4f57'; 
            ctx.lineWidth = 1;
            ctx.strokeRect(c * cell, r * cell, cell, cell);
          }
        }
      }

      function renderBoard() {
        try {
          // Check if module memory is available
          if (!mod || !mod.HEAPF32) {
            console.warn("Module or HEAPF32 not ready");
            return;
          }
          
          // Get Player 1's board and heatmap
          const ptr1 = snap1();
          const hptr1 = heat1();
          const data1 = new Float32Array(mod.HEAPF32.buffer, ptr1, 100);
          const hdata1 = new Float32Array(mod.HEAPF32.buffer, hptr1, 100);
          
          // Get Player 2's board and heatmap
          const ptr2 = snap2();
          const hptr2 = heat2();
          const data2 = new Float32Array(mod.HEAPF32.buffer, ptr2, 100);
          const hdata2 = new Float32Array(mod.HEAPF32.buffer, hptr2, 100);
          
          // Debug: log first render
          if (!renderBoard.hasRendered) {
            console.log('First render - Board 1 sample:', Array.from(data1.slice(0, 10)));
            console.log('First render - Board 2 sample:', Array.from(data2.slice(0, 10)));
            console.log('First render - Heat 1 sample:', Array.from(hdata1.slice(0, 10)));
            renderBoard.hasRendered = true;
          }
          
          // Render both boards using the visible (CSS) size so drawing matches layout
          const w1 = canvas1.clientWidth || canvas1.width;
          const h1 = canvas1.clientHeight || canvas1.height;
          const w2 = canvas2.clientWidth || canvas2.width;
          const h2 = canvas2.clientHeight || canvas2.height;
          renderBoardToCanvas(ctx1, data1, hdata1, w1, h1);
          renderBoardToCanvas(ctx2, data2, hdata2, w2, h2);
          
          // Count stats for each board
          let hits1 = 0, misses1 = 0;
          let hits2 = 0, misses2 = 0;
          
          for (let i = 0; i < 100; i++) {
            if (data1[i] === 1) hits1++;
            else if (data1[i] === -1) misses1++;
            
            if (data2[i] === 1) hits2++;
            else if (data2[i] === -1) misses2++;
          }
          
          // Update stats displays
          p1Stats = { hits: hits2, misses: misses2, total: hits2 + misses2 };
          p2Stats = { hits: hits1, misses: misses1, total: hits1 + misses1 };
          
          updateStats(1, p1Stats.hits, p1Stats.misses, p1Stats.total);
          updateStats(2, p2Stats.hits, p2Stats.misses, p2Stats.total);
        } catch (err) {
          console.error("Error rendering board:", err);
          console.error(err.stack);
        }
      }

      function appendLog(line) {
        if (!line) return;
        logEl.textContent += line + "\n";
        logEl.scrollTop = logEl.scrollHeight;
      }

      let stepModeEnabled = false;
      let currentTotalGames = 0;
      function warGamesRamp(totalGames) {
        // If user requests many games, cap final rate to avoid browser lag
        // Allow speed override via slider
        const sliderRate = Number(speedSlider.value) || 60;
        speedVal.textContent = sliderRate;
        const finalRate = Math.min(sliderRate, totalGames >= 50 ? 30 : 60);
        let phases = [
          { rate: 2,  durationMs: 3000 },  // slow to savor
          { rate: 8,  durationMs: 3000 },
          { rate: 20, durationMs: 2000 },
          { rate: finalRate, durationMs: 0 },
        ];
        let phaseIndex = 0, lastSwitch = performance.now();
        let accumulator = 0, last = performance.now();

        function loop(now) {
          if (stepModeEnabled) return; // do not auto-loop in step mode
          try {
            const dt = (now - last) / 1000.0; last = now;
            const phase = phases[phaseIndex] || phases[phases.length-1];
            const interval = 1.0 / phase.rate;
            accumulator += dt;
            while (accumulator >= interval) {
              accumulator -= interval;
              const msg = tick();
              if (msg) appendLog(msg);
              renderBoard();
              if (done()) {
                appendLog('[Tournament complete]');
                return;
              }
            }
            if (phase.durationMs > 0 && now - lastSwitch > phase.durationMs) {
              phaseIndex++; lastSwitch = now;
              const nextRate = phases[phaseIndex]?.rate ?? phases[phaseIndex-1].rate;
              appendLog(`[Speed increased to ${nextRate} ticks/sec]`);
            }
            requestAnimationFrame(loop);
          } catch (err) {
            console.error("Error in game loop:", err);
            appendLog(`[Error: ${err.message}]`);
          }
        }
        requestAnimationFrame(loop);
      }

      const stepBtn = document.getElementById('step');
      const stepModeChk = document.getElementById('stepMode');

      const resumeBtn = document.getElementById('resume');
      stepModeChk.onchange = () => {
        stepModeEnabled = stepModeChk.checked;
        stepBtn.disabled = !stepModeEnabled;
        resumeBtn.disabled = !stepModeEnabled;
      };

      // Slider displays
      speedSlider.oninput = () => { speedVal.textContent = speedSlider.value; };
      alphaSlider.oninput = () => { alphaVal.textContent = parseFloat(alphaSlider.value).toFixed(2); };
      placeSlider.oninput = () => { placeVal.textContent = parseFloat(placeSlider.value).toFixed(2); };
      adjSlider.oninput = () => { adjVal.textContent = parseFloat(adjSlider.value).toFixed(2); };
      mcSlider.oninput = () => { mcVal.textContent = parseFloat(mcSlider.value).toFixed(2); };

      startBtn.onclick = () => {
        try {
          logEl.textContent = '';
          const mode = Number(modeSel.value);
          const games = Number(gamesInput.value);
          currentTotalGames = games;
          appendLog(`[Tournament started: mode=${mode}, games=${games}]`);
          console.log('Starting tournament...');
          start(mode, games);
          console.log('Tournament started, rendering initial board...');
          renderBoard();
          console.log('Starting animation loop...');
          if (!stepModeEnabled) warGamesRamp(games);
        } catch (err) {
          console.error("Error starting tournament:", err);
          appendLog(`[Error: ${err.message}]`);
        }
      };

      stepBtn.onclick = () => {
        if (!stepModeEnabled) return;
        if (done()) { appendLog('[Tournament complete]'); return; }
        const msg = tick();
        if (msg) appendLog(msg);
        renderBoard();
      };

      resumeBtn.onclick = () => {
        // Resume autoplay: disable step controls and start ramp
        if (done()) { appendLog('[Tournament complete]'); return; }
        stepModeChk.checked = false;
        stepModeEnabled = false;
        stepBtn.disabled = true;
        resumeBtn.disabled = true;
        if (currentTotalGames > 0) {
          warGamesRamp(currentTotalGames);
          appendLog('[Resumed autoplay]');
        } else {
          warGamesRamp(Number(gamesInput.value));
          appendLog('[Resumed autoplay]');
        }
      };

      // Build an array of 16 floats matching AIWeights layout then call WASM setter
      function applyAIWeightsFromUI() {
        if (!mod || !setAIWeights || !mod._malloc) {
          appendLog('[WASM not ready for setting AI weights]');
          return;
        }
        // Read current weights into buffer to preserve unchanged fields
        const buf = mod._malloc(16 * 4);
        try {
          getAIWeights(buf);
          const view = new Float32Array(mod.HEAPF32.buffer, buf, 16);
          // Update fields we allow editing
          view[0] = parseFloat(alphaSlider.value); // globalAlphaEarly
          // leave globalAlphaLate as-is
          view[6] = parseFloat(adjSlider.value);   // adjHitBonus
          view[12] = parseFloat(placeSlider.value); // placementHitMultiplier
          view[14] = parseFloat(mcSlider.value);   // mcBlendRatio
          // call WASM setter
          setAIWeights(buf);
          appendLog('[AI weights applied]');
        } finally {
          mod._free(buf);
        }
      }

      applyAIBtn.onclick = () => {
        applyAIWeightsFromUI();
      };

      // Quick trial: run a 20-game tournament asynchronously and report final CSV-like message
      quickTrialBtn.onclick = async () => {
        try {
          appendLog('[Starting quick 20-game trial]');
          start(3, 20);
          // Run ticks in small batches to avoid locking UI
          let lastMsg = null;
          while (!done()) {
            // run a few ticks per paint
            for (let i = 0; i < 20 && !done(); ++i) {
              const msg = tick();
              if (msg) lastMsg = msg;
            }
            renderBoard();
            await new Promise(r => setTimeout(r, 1));
          }
          // one final tick to obtain end message if not already
          const finalMsg = lastMsg || tick();
          appendLog('[Quick trial complete] ' + (finalMsg || ''));
          // try to parse P1 avg shots from final message
          const m = /P1 avg shots:\s*([0-9]+\.?[0-9]*)/.exec(finalMsg || '');
          if (m) appendLog('[P1 avg shots] ' + m[1]);
        } catch (err) {
          appendLog('[Quick trial error] ' + err.message);
        }
      };

      // Fetch tuner_output.csv, pick best row by P1 avg, and apply weights
      applyBestBtn.onclick = async () => {
        try {
          appendLog('[Loading tuner_output.csv]');
          const resp = await fetch('tuner_output.csv');
          if (!resp.ok) { appendLog('[Failed to load tuner_output.csv]'); return; }
          const txt = await resp.text();
          const lines = txt.split('\n').map(l => l.trim()).filter(l => l.length);
          if (lines.length <= 1) { appendLog('[No data in tuner_output.csv]'); return; }
          const header = lines[0].split(',');
          let best = null; let bestVal = Infinity;
          for (let i = 1; i < lines.length; ++i) {
            const cols = lines[i].split(',');
            if (cols.length < 7) continue;
            const p1 = parseFloat(cols[6]);
            if (!isFinite(p1)) continue;
            if (p1 < bestVal) { bestVal = p1; best = cols; }
          }
          if (!best) { appendLog('[No valid rows found]'); return; }
          // columns: alphaEarly,placementHitMultiplier,adjHitBonus,mcBlendRatio,games,threads,p1_avg_shots,p2_avg_shots
          const alpha = parseFloat(best[0]);
          const place = parseFloat(best[1]);
          const adj = parseFloat(best[2]);
          const mc = parseFloat(best[3]);
          // apply to UI
          alphaSlider.value = alpha; alphaVal.textContent = alpha.toFixed(2);
          placeSlider.value = place; placeVal.textContent = place.toFixed(2);
          adjSlider.value = adj; adjVal.textContent = adj.toFixed(2);
          mcSlider.value = mc; mcVal.textContent = mc.toFixed(2);
          applyAIWeightsFromUI();
          appendLog('[Applied best tuner weights — running quick confirmation]');
          quickTrialBtn.click();
        } catch (err) {
          appendLog('[Error applying best weights] ' + err.message);
        }
      };

      // Preset handling with localStorage persistence
      const PRESET_KEY = 'battleship_presets_v1';
      // Default built-in presets
      const builtinPresets = {
        'default': null,
        'fast-center': { globalAlphaEarly: 0.7, placementHitMultiplier: 1.5, adjHitBonus: 0.3, mcBlendRatio: 0.0 },
        'tuned-best': { globalAlphaEarly: 0.8, placementHitMultiplier: 2.0, adjHitBonus: 0.2, mcBlendRatio: 0.5 }
      };

      // Load presets from localStorage (merge with builtins)
      let presets = Object.assign({}, builtinPresets);
      try {
        const raw = localStorage.getItem(PRESET_KEY);
        if (raw) {
          const parsed = JSON.parse(raw);
          if (parsed && typeof parsed === 'object') presets = Object.assign({}, presets, parsed);
        }
      } catch (err) {
        console.warn('Failed to load presets from localStorage:', err);
      }

      // Populate preset selector
      function refreshPresetOptions() {
        // clear existing (preserve first three builtin options ordering)
        presetSel.innerHTML = '';
        for (const k of Object.keys(presets)) {
          const opt = document.createElement('option'); opt.value = k; opt.textContent = k; presetSel.appendChild(opt);
        }
      }
      refreshPresetOptions();

      presetSel.onchange = () => {
        const k = presetSel.value;
        if (k && presets[k]) {
          const p = presets[k];
          if (p.globalAlphaEarly !== undefined) { alphaSlider.value = p.globalAlphaEarly; alphaVal.textContent = p.globalAlphaEarly.toFixed(2); }
          if (p.placementHitMultiplier !== undefined) { placeSlider.value = p.placementHitMultiplier; placeVal.textContent = p.placementHitMultiplier.toFixed(2); }
          if (p.adjHitBonus !== undefined) { adjSlider.value = p.adjHitBonus; adjVal.textContent = p.adjHitBonus.toFixed(2); }
          if (p.mcBlendRatio !== undefined) { mcSlider.value = p.mcBlendRatio; mcVal.textContent = p.mcBlendRatio.toFixed(2); }
        }
      };

      savePresetBtn.onclick = () => {
        const name = prompt('Preset name:');
        if (!name) return;
        presets[name] = {
          globalAlphaEarly: parseFloat(alphaSlider.value),
          placementHitMultiplier: parseFloat(placeSlider.value),
          adjHitBonus: parseFloat(adjSlider.value),
          mcBlendRatio: parseFloat(mcSlider.value)
        };
        try {
          localStorage.setItem(PRESET_KEY, JSON.stringify(presets));
          refreshPresetOptions();
          presetSel.value = name;
          appendLog('[Saved preset: ' + name + ']');
        } catch (err) {
          appendLog('[Failed to save preset: ' + err.message + ']');
        }
      };

      // parseConfirmCSV: parse tuner_1000_confirm.csv and render summary with clickable best row
      let confirmBest = null;
      async function parseConfirmCSV() {
        try {
          const resp = await fetch('tuner_1000_confirm.csv');
          if (!resp.ok) { tunerSummary.textContent = 'No confirm file.'; return; }
          const txt = await resp.text();
          const lines = txt.split('\n').map(l=>l.trim()).filter(l=>l.length);
          if (lines.length <= 1) { tunerSummary.textContent = 'No data in confirm CSV.'; return; }
          let best = null, worst = null, sum = 0, count=0;
          for (let i = 1; i < lines.length; ++i) {
            const cols = lines[i].split(','); if (cols.length < 7) continue;
            const p1 = parseFloat(cols[6]);
            if (!isFinite(p1)) continue;
            sum += p1; count++;
            if (!best || p1 < best.p1) best = { p1, cols };
            if (!worst || p1 > worst.p1) worst = { p1, cols };
          }
          if (count === 0) { tunerSummary.textContent = 'No numeric data in confirm CSV.'; return; }
          const avg = sum / count;
          confirmBest = best;
          // Render summary and make the Best line clickable
          tunerSummary.innerHTML = '';
          const info = document.createElement('div'); info.textContent = `Confirm CSV: rows=${count} avgP1=${avg.toFixed(3)}`;
          const bestDiv = document.createElement('div');
          bestDiv.style.cursor = 'pointer';
          bestDiv.title = 'Click to apply this best config and run a quick trial';
          bestDiv.innerHTML = `Best: <strong>${best.p1.toFixed(3)}</strong> &nbsp; Config: ${best.cols.slice(0,4).join(',')}`;
          bestDiv.onclick = () => {
            if (!confirmBest) return;
            const cols = confirmBest.cols;
            const alpha = parseFloat(cols[0]);
            const place = parseFloat(cols[1]);
            const adj = parseFloat(cols[2]);
            const mc = parseFloat(cols[3]);
            alphaSlider.value = alpha; alphaVal.textContent = alpha.toFixed(2);
            placeSlider.value = place; placeVal.textContent = place.toFixed(2);
            adjSlider.value = adj; adjVal.textContent = adj.toFixed(2);
            mcSlider.value = mc; mcVal.textContent = mc.toFixed(2);
            applyAIWeightsFromUI();
            appendLog('[Applied confirm-best weights — running quick confirmation]');
            quickTrialBtn.click();
          };
          const worstDiv = document.createElement('div'); worstDiv.textContent = `Worst: ${worst.p1.toFixed(3)}   Config: ${worst.cols.slice(0,4).join(',')}`;
          tunerSummary.appendChild(info);
          tunerSummary.appendChild(bestDiv);
          tunerSummary.appendChild(worstDiv);
        } catch (err) { tunerSummary.textContent = 'Error reading confirm CSV: '+err.message; }
      }

      // Try parsing on load
      parseConfirmCSV();
      
      // Autoplay / muted query-param handling
      (function() {
        function getParam(name) {
          try { return new URLSearchParams(window.location.search).get(name); } catch (e) { return null; }
        }
        const autoplay = getParam('autoplay') === '1';
        const muted = getParam('muted') === '1';

        function applyMuted() {
          try {
            // Mute any audio elements and expose a flag for other code
            document.querySelectorAll('audio').forEach(a => a.muted = true);
            window._battleship_demo_muted = true;
          } catch (e) { console.warn('mute failed', e); }
        }

        function startIfNeeded() {
          if (muted) applyMuted();
          if (!autoplay) return;
          try {
            // Use same startup logic as the Start button
            logEl.textContent = '';
            const mode = Number(modeSel.value);
            const games = Number(gamesInput.value);
            currentTotalGames = games;
            appendLog(`[Tournament started: mode=${mode}, games=${games}] (autoplay)`);
            start(mode, games);
            renderBoard();
            if (!stepModeEnabled) warGamesRamp(games);
          } catch (e) {
            console.warn('autoplay start failed', e);
          }
        }

        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', startIfNeeded);
        } else {
          startIfNeeded();
        }
      })();
      
      // Draw initial empty boards to show canvas is working
      function drawInitialBoards() {
        // Use the displayed client size so the placeholder scales with container
        [[canvas1, ctx1], [canvas2, ctx2]].forEach(([canvas, ctx]) => {
          const dpr = window.devicePixelRatio || 1;
          const cw = canvas.clientWidth || 400;
          const ch = canvas.clientHeight || cw;
          // size the drawing buffer
          canvas.width = Math.floor(cw * dpr);
          canvas.height = Math.floor(ch * dpr);
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

          // Clear and draw grid based on CSS pixels
          ctx.fillStyle = '#0b0e12';
          ctx.fillRect(0, 0, cw, ch);
          const size = 10, cell = cw / size;
          for (let r = 0; r < size; r++) {
            for (let c = 0; c < size; c++) {
              ctx.fillStyle = '#1a1d24';
              ctx.fillRect(c * cell + 1, r * cell + 1, cell - 2, cell - 2);
              ctx.strokeStyle = '#4a4f57';
              ctx.lineWidth = 1;
              ctx.strokeRect(c * cell, r * cell, cell, cell);
            }
          }
          // Add "Ready" text
          ctx.fillStyle = '#888';
          ctx.font = 'bold 24px monospace';
          ctx.textAlign = 'center';
          ctx.fillText('Click Start', cw / 2, ch / 2);
        });
      }

      // Keep canvas drawing buffers sized to the display size (handles hi-dpi)
      function resizeCanvases() {
        const dpr = window.devicePixelRatio || 1;
        [[canvas1, ctx1], [canvas2, ctx2]].forEach(([canvas, ctx]) => {
          const cw = canvas.clientWidth || 400;
          const ch = canvas.clientHeight || cw;
          canvas.width = Math.floor(cw * dpr);
          canvas.height = Math.floor(ch * dpr);
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        });
      }

      window.addEventListener('resize', function() { resizeCanvases(); renderBoard(); });
      
      // Initialize boards on load
      drawInitialBoards();
    </script>
  </body>
</html>
