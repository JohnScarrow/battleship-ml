#include "battleship.h"
#include "MLforAI.h"

void welcomeScreen() {
    cout << "***** Welcome to Battleship! *****\n\n";
    cout << "Rules of the Game:\n";
    cout << "1. Player1 is you and Player2 is the computer.\n";
    cout << "2. Columns are Aâ€“J, rows are 0-9.\n";
    cout << "3. Ships: carrier(5), battleship(4), cruiser(3), submarine(3), destroyer(2).\n";
    cout << "4. '*' marks a hit; 'm' marks a miss; you cannot shoot the same cell twice.\n";
    cout << "5. First to sink all ships wins.\n\n";
    cout << "Press Enter to start...";
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
}

/**
 * Initialize a board by setting all cells to '-'.
 *
 * @param board The board to initialize.
 */
void initializeBoard(char board[NUM_ROWS][NUM_COLS]) {
    for (int r = 0; r < NUM_ROWS; ++r)
        for (int c = 0; c < NUM_COLS; ++c)
            board[r][c] = '-';
}

/**
 * @brief Check if a ship can be placed on the board at the given position.
 *
 * @param board The board to check.
 * @param row The row of the position to check.
 * @param col The column of the position to check.
 * @param size The size of the ship to check.
 * @param horizontal If true, the ship is placed horizontally; if false, the ship is placed vertically.
 * @return true if the ship can be placed at the given position, false otherwise.
 */
bool canPlaceShip(const char board[NUM_ROWS][NUM_COLS], int row, int col, int size, bool horizontal) {
    if (row < 0 || row >= NUM_ROWS || col < 0 || col >= NUM_COLS) return false;
    if (horizontal) {
        if (col + size > NUM_COLS) return false;
        for (int i = 0; i < size; ++i) if (board[row][col + i] != '-') return false;
    } else {
        if (row + size > NUM_ROWS) return false;
        for (int i = 0; i < size; ++i) if (board[row + i][col] != '-') return false;
    }
    return true;
}

/**
 * Place a ship on the board at the given position.
 *
 * @param board The board to place the ship on.
 * @param row The row of the position to place the ship.
 * @param col The column of the position to place the ship.
 * @param size The size of the ship to place.
 * @param symbol The symbol to use to mark the ship on the board.
 * @param horizontal If true, the ship is placed horizontally; if false, the ship is placed vertically.
 */
void placeShip(char board[NUM_ROWS][NUM_COLS], int row, int col, int size, char symbol, bool horizontal) {
    if (horizontal) for (int i = 0; i < size; ++i){
        board[row][col + i] = symbol;
    }else {
        for (int i = 0; i < size; ++i){
            board[row + i][col] = symbol;
        }
    }
}

/**
 * @brief Convert a letter to its corresponding column index on the board.
 *
 * The input character will be converted to uppercase and then its ASCII value
 * will be subtracted from the ASCII value of 'A' to get the column index.
 *
 * For example, if the input character is 'A', the function will return 0. If the input
 * character is 'B', the function will return 1. And so on.
 *
 * If the input character is not a valid column index (i.e. it is not a letter between
 * 'A' and 'J', inclusive), the function will return -1.
 *
 * @param colChar The letter to convert to its corresponding column index.
 * @return The column index corresponding to the input character, or -1 if the input character
 *         is not a valid column index.
 */
int letterToCol(char colChar) {
    char up = static_cast<char>(toupper(static_cast<unsigned char>(colChar)));
    int col = up - 'A';
    return (col >= 0 && col < NUM_COLS) ? col : -1;
}

/**
 * @brief Convert a column index to its corresponding letter on the board.
 *
 * The column index will be added to the ASCII value of 'A' to get the corresponding
 * letter. For example, if the column index is 0, the function will return 'A'. If
 * the column index is 1, the function will return 'B'. And so on.
 *
 * If the column index is not a valid column index (i.e. it is not between 0 and
 * NUM_COLS - 1, inclusive), the function will return a garbage value.
 *
 * @param col The column index to convert to its corresponding letter.
 * @return The letter corresponding to the input column index, or a garbage value if
 *         the input column index is not a valid column index.
 */
char colToLetter(int col) {
    return static_cast<char>('A' + col);
}

/**
 * Place all ships on the board in a biased manner, with the bias being in the center of the board.
 * The bias is generated by the generatePlacementWeights function, which assigns higher weights to the center of the board.
 * The ships are placed one by one, with the Carrier being placed first, the Battleship being placed second, and so on.
 * Each ship is placed at a random position that is not already occupied by another ship, and the orientation of the ship is also randomly chosen.
 * This function is used for Player2 (the computer) to place its ships on the board.
 */
void biasedPlaceShipsOnBoard(char board[NUM_ROWS][NUM_COLS]) {
    double weights[NUM_ROWS][NUM_COLS];
    generatePlacementWeights(weights);

    for (int s = 0; s < NUM_SHIPS; ++s) {
        bool placed = false;
        while (!placed) {
            auto [row, col] = pickWeightedCell(weights);
            bool horizontal = rand() % 2;

            if (canPlaceShip(board, row, col, SHIP_SIZES[s], horizontal)) {
                placeShip(board, row, col, SHIP_SIZES[s], SHIP_SYMBOLS[s], horizontal);
                placed = true;
            }
        }
    }
}

/**
 * Manually place all ships on the board. The user is prompted to choose between manual and random placement.
 * If the user chooses manual placement, they are prompted to enter the start row and column for each ship,
 * as well as the orientation (horizontal or vertical). The program checks for invalid inputs and overlap
 * with existing ships. If the user chooses random placement, the randomlyPlaceShipsOnBoard function is called.
 */
void manuallyPlaceShipsOnBoard(char board[NUM_ROWS][NUM_COLS]) {
    cout << "\n1. Manual placement\n2. Random placement\nChoice: ";
    int choice; cin >> choice;
    if (choice == 2) { randomlyPlaceShipsOnBoard(board); return; }

    for (int i = 0; i < NUM_SHIPS; ++i) {
        bool placed = false;
        while (!placed) {
            cout << "Place " << SHIP_NAMES[i] << " (size " << SHIP_SIZES[i] << ")\n";
            cout << "Enter start row and column (e.g. 3 D or D 3): ";
            auto [row, col] = parseFlexibleInput();

            cout << "Orientation [0=H,1=V]: ";
            int o; cin >> o; bool horiz = (o == 0);

            if (row < 0 || row >= NUM_ROWS || col < 0 || col >= NUM_COLS) { cout << "Invalid.\n"; continue; }
            if (!canPlaceShip(board, row, col, SHIP_SIZES[i], horiz)) { cout << "Overlap/out of bounds.\n"; continue; }

            placeShip(board, row, col, SHIP_SIZES[i], SHIP_SYMBOLS[i], horiz);
            placed = true;
            // clearScreen removed for WASM
            cout << "Player1's Board:\n\n";
            displayBoard(board, true);
        }
    }
}

/**
 * Randomly place all ships on the board.
 *
 * For each ship, attempt to randomly place it on the board up to 1000 times. If a ship cannot be
 * placed after 1000 attempts, use a brute-force approach to place the ship.
 *
 * @param board The board to place the ships on.
 */
void randomlyPlaceShipsOnBoard(char board[NUM_ROWS][NUM_COLS]) {
    for (int i = 0; i < NUM_SHIPS; ++i) {
        bool placed = false;
        for (int attempts = 0; attempts < 1000 && !placed; ++attempts) {
            int row = rand() % NUM_ROWS;
            int col = rand() % NUM_COLS;
            bool horiz = (rand() % 2 == 0);
            if (canPlaceShip(board, row, col, SHIP_SIZES[i], horiz)) {
                placeShip(board, row, col, SHIP_SIZES[i], SHIP_SYMBOLS[i], horiz);
                placed = true;
            }
        }
        if (!placed) { // brute-force fallback
            for (int r = 0; r < NUM_ROWS && !placed; ++r)
                for (int c = 0; c < NUM_COLS && !placed; ++c)
                    for (int h = 0; h < 2 && !placed; ++h) {
                        bool horiz = (h == 0);
                        if (canPlaceShip(board, r, c, SHIP_SIZES[i], horiz)) {
                            placeShip(board, r, c, SHIP_SIZES[i], SHIP_SYMBOLS[i], horiz);
                            placed = true;
                        }
                    }
        }
    }
}

/**
 * Randomly selects which player goes first in the game.
 * Prints out the result and pauses for a short time.
 * @return 0 if Player1 goes first, 1 if Player2 goes first.
 */
int selectWhoStartsFirst() {
    int who = rand() % 2;
    // In WASM, no console output
    return who;
}

/**
 * @brief Check if a shot is available at the given position.
 * 
 * Check if the position is within the bounds of the board and if the cell at the position is either empty ('-') or a ship symbol.
 *
 * @param board The board to check.
 * @param row The row of the position to check.
 * @param col The column of the position to check.
 * @return true if the shot is available, false otherwise.
 */
bool checkShotIsAvailable(const char board[NUM_ROWS][NUM_COLS], int row, int col) {
    if (row < 0 || row >= NUM_ROWS || col < 0 || col >= NUM_COLS) return false;
    char cell = board[row][col];
    return cell == '-' || isShipSymbol(cell);
}

/**
 * Updates the board after a shot is taken.
 * If the shot hits a ship, marks the cell with 'X' and returns the index of the ship in shipSizes.
 * If the shot is a miss, marks the cell with 'm' and returns -1.
 * @param board The board to update.
 * @param row The row of the position of the shot.
 * @param col The column of the position of the shot.
 * @param shipSizes The sizes of the ships.
 * @return The index of the ship if the shot hits, -1 if the shot is a miss.
 */
int updateBoard(char board[NUM_ROWS][NUM_COLS], int row, int col, int shipSizes[]) {
    char &cell = board[row][col];
    if (isShipSymbol(cell)) {
        int idx = -1;
        for (int i = 0; i < NUM_SHIPS; ++i)
            if (cell == SHIP_SYMBOLS[i]) { idx = i; break; }
        cell = 'X';
        return idx;
    } else {
        cell = 'm';
        return -1;
    }
}


/**
 * @brief Check if a player has won the game.
 * 
 * Check if all ships on the board have been sunk.
 * 
 * @param shipSizes An array of the current sizes of the ships.
 * @return true if the player has won the game, false otherwise.
 */
bool isWinner(const int shipSizes[]) {
    for (int i = 0; i < NUM_SHIPS; ++i) if (shipSizes[i] > 0) return false;
    return true;
}

// outputCurrentMove removed for WASM - no file I/O

/**
 * @brief Update the size of a ship after being hit.
 * 
 * Decrement the size of the ship at the given index in shipSizes.
 * If the ship has been sunk (its size is 0), return true.
 * If the ship index is out of bounds, return false.
 * 
 * @param shipSizes An array of the current sizes of the ships.
 * @param shipIndex The index of the ship to update.
 * @return true if the ship has been sunk, false otherwise.
 */
bool updateShipSize(int shipSizes[], int shipIndex) {
    if (shipIndex < 0 || shipIndex >= NUM_SHIPS) return false;
    if (shipSizes[shipIndex] > 0) {
        --shipSizes[shipIndex];
        return shipSizes[shipIndex] == 0;
    }
    return false;
}

// outputStats removed for WASM - no file I/O

/**
 * Checks if a character is a ship symbol.
 * 
 * Iterates over SHIP_SYMBOLS and checks if the given character is equal to any of the symbols.
 * 
 * @param ch The character to check.
 * @return true if the character is a ship symbol, false otherwise.
 */
bool isShipSymbol(char ch) {
    for (int i = 0; i < NUM_SHIPS; ++i){
        if (ch == SHIP_SYMBOLS[i]){
            return true;
        }
    }
    return false;
}

/**
 * Displays the board in a human-readable format.
 * The board is displayed as a grid of characters, with row labels on the left and column labels on top.
 * If showShips is false, ship symbols are replaced with '-'.
 * @param board The board to display.
 * @param showShips Whether to show ship symbols or not.
 */
void displayBoard(const char board[NUM_ROWS][NUM_COLS], bool showShips) {
    // Print column labels
    cout << "   ";
    for (int c = 0; c < NUM_COLS; ++c){
        cout << static_cast<char>('A' + c) << " ";
    }
    cout << "\n";

    // Print board
    for (int r = 0; r < NUM_ROWS; ++r) {
        cout << setw(2) << r << " ";
        for (int c = 0; c < NUM_COLS; ++c) {
            char cell = board[r][c];

        // If showShips is false, replace ship symbols with '-'
            if (!showShips && isShipSymbol(cell)){
                cell = '-';
            }else{ cout << cell << " ";
            }
        }
        cout << "\n";
    }
}

/**
 * Gets a move from the specified player.
 * 
 * If the player is human, prompts the user to enter a target in the format "row colLetter" or "colLetter row".
 * If the player is a computer, randomly selects a target that is still available.
 * 
 * @param type The type of player (human or computer).
 * @param board The current game board.
 * @return A pair of integers representing the row and column of the selected target.
 */
pair<int,int> getMove(PlayerType type, const char board[NUM_ROWS][NUM_COLS]) {
    if (type == HUMAN) {
        cout << "Enter target (row colLetter or colLetter row): ";
        auto [row, col] = parseFlexibleInput();
        return {row, col};
    } else {
        int row, col;
        do {
            row = rand() % NUM_ROWS;
            col = rand() % NUM_COLS;
        } while (!checkShotIsAvailable(board, row, col));
        // Console output removed for WASM
        return {row, col};
    }
}

/**
 * Parses a user input string in a flexible format to extract a row and column target.
 * 
 * The input is expected to be a single line of text, and may contain spaces, commas, and/or
 * letters and digits. The function removes all commas and whitespace, then separates the letters
 * and digits.
 * 
 * If the input is in the format of "row colLetter" or "colLetter row", the function will return
 * a pair of integers representing the target.
 * 
 * If the input cannot be parsed, the function returns a pair of {-1, -1}.
 * 
 * @return A pair of integers representing the target row and column, or {-1, -1} if the input
 * could not be parsed.
 */
pair<int,int> parseFlexibleInput() {
    // Read a full line (consumes the newline if any) so single-token inputs like "A5"
    // or "5A" are handled without blocking for a second token.
    string line;
    if (!getline(cin >> ws, line)) return {-1, -1};

    // Remove commas and whitespace, then separate letters and digits
    line.erase(remove(line.begin(), line.end(), ','), line.end());
    string compact;
    for (char ch : line) if (!isspace(static_cast<unsigned char>(ch))) compact.push_back(ch);

    string digits, letters;
    for (char ch : compact) {
        if (isdigit(static_cast<unsigned char>(ch))) digits.push_back(ch);
        else if (isalpha(static_cast<unsigned char>(ch))) letters.push_back(ch);
    }

    int row = -1, col = -1;
    if (!digits.empty() && !letters.empty()) {
        // Common cases: "3D" or "D3" or "3D," etc.
        row = stoi(digits);
        col = letterToCol(letters[0]);
        return {row, col};
    }

    // Fallback: try to parse as two space-separated tokens
    string token1, token2;
    stringstream ss(compact);
    if (ss >> token1 >> token2) {
        if (!token1.empty() && isdigit(static_cast<unsigned char>(token1[0]))) {
            row = stoi(token1);
            col = letterToCol(token2[0]);
        } else {
            col = letterToCol(token1[0]);
            row = stoi(token2);
        }
        return {row, col};
    }

    // Unrecognized input
    return {-1, -1};
}


